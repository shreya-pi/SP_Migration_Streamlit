# --- START OF FILE scripts/process_procs_st.py ---

import streamlit as st
import os
import pandas as pd
from pathlib import Path
from scripts.py_test import run_single_test
from scripts.py_output import PyOutput 
from scripts import py_test
import importlib   
import unittest
import io
import re
from difflib import HtmlDiff
import streamlit.components.v1 as components

class ProcessProcsPage:
    def __init__(self, config: dict):
        """
        Initializes the UI page for processing and comparing converted procedures.
        """
        if not config:
            raise ValueError("Configuration is required.")
        self.config = config
        
        # Define directories using config for flexibility, with sensible defaults
        self.converted_dir = Path(config.get("SNOWCONVERT_OUTPUT_DIR", "./converted_procedures")) / "Output" / "SnowConvert"
        self.extracted_dir = Path(config.get("SQL_OUTPUT_DIR", "./extracted_procedures"))
        self.processed_dir = Path("./processed_procedures")

                # Initialize session state for the editable content
        if "editable_file_path" not in st.session_state:
            st.session_state.editable_file_path = None
        if "editable_content" not in st.session_state:
            st.session_state.editable_content = ""
        if "edit_mode" not in st.session_state:
            st.session_state.edit_mode = False

    def display_page(self):
        """
        Renders the entire UI for this component.
        """
        # --- Container 1: The Processing Action ---
        with st.container(border=True):
            st.subheader("âš™ï¸ Process Converted Scripts")
            st.markdown(
                """
                This step performs final transformations on the files generated by SnowConvert,
                such as replacing placeholder schema names, to make them ready for testing and deployment.
                """
            )
            col1, col2 = st.columns(2)
            with col1:
                source_schema = st.text_input("Source Schema (to be replaced)", value="dbo", key="source_schema_input")
            with col2:
                target_schema = st.text_input("Target Snowflake Schema", value="MIGRATION_SCHEMA", key="target_schema_input")
            
            if st.button("ðŸš€ **Process All Files**", use_container_width=True, type="primary"):
                try:
                    from scripts.process_sc_script import ScScriptProcessor
                    with st.spinner(f"Processing files from {self.processed_dir}..."):
                        processor = ScScriptProcessor(source_schema, target_schema)
                        processor.process_all_files()
                    st.success("âœ… All files processed successfully!")
                    # Signal completion back to the main app if using that pattern
                    if 'step_completion' in st.session_state:
                        st.session_state.step_completion['process_converted_procs'] = True
                except Exception as e:
                    st.error("âŒ An error occurred during processing:")
                    st.exception(e)
        
        st.markdown("---")

        # --- Container 2: The Comparison Viewer ---
        with st.container(border=True):
            st.subheader("ðŸ“Š Compare Original vs. Converted Scripts")
            st.caption("Select a procedure to see a side-by-side comparison of the original SQL Server script and the post-SnowConvert version.")
            
            self.display_comparison_viewer()


        # --- Container 3: The File Editor ---
    
    
    def _load_file_for_editing(self):
        """Callback to load file content when dropdown selection changes."""
        # selected_file = st.session_state.get("file_comparator_select")
        rich_label = st.session_state.get("file_comparator_select")

        st.session_state.edit_mode = False

        if rich_label and rich_label != "-- Select a procedure to compare --":
            # Extract the actual filename from the rich label (e.g., "my_proc.sql  [âœ…]" -> "my_proc.sql")
            # selected_file = rich_label.split(' [STATUS-')[0].strip()
            selected_file = rich_label.split('  [')[0].strip()
            
            file_path = self.processed_dir / f"processed_{selected_file}"
            if file_path.exists():
                st.session_state.editable_file_path = str(file_path)
                st.session_state.editable_content = self.read_file_content(file_path)
            else:
                st.session_state.editable_file_path = None
                st.session_state.editable_content = f"--- ERROR: FILE NOT FOUND ---\n{file_path}"
        else:
            st.session_state.editable_file_path = None
            st.session_state.editable_content = ""




    def display_comparison_viewer(self):
        """
        Handles the logic for file comparison, with status indicators in the dropdown.
        """

        if 'current_file_for_tests' not in st.session_state or \
            st.session_state.current_file_for_tests != st.session_state.editable_file_path:
                st.session_state.test_results = None
                st.session_state.current_file_for_tests = st.session_state.editable_file_path


        if not self.processed_dir.exists() or not self.extracted_dir.exists():
            st.warning(f"âš ï¸ Required directories not found."); return

        try:
            # --- STEP 1: Fetch test statuses ---
            output_viewer = PyOutput(config=self.config) 
            results_data, column_names = output_viewer.display_PyOutput()
            status_map = {}
            if results_data:
                df = pd.DataFrame(results_data, columns=column_names)
                # Get the LATEST test status for each procedure
                latest_statuses = df.sort_values('TEST_TIMESTAMP').drop_duplicates('PROCEDURE_NAME', keep='last')
                # Create a simple lookup dictionary: {proc_name: status_icon}
                status_map = {row['PROCEDURE_NAME']: row['STATUS'] for index, row in latest_statuses.iterrows()}
  
            
            # --- STEP 2: Build rich labels for the dropdown ---
            converted_files = sorted([f.name for f in self.processed_dir.glob("*.sql")])
            if not converted_files:
                st.info("No converted SQL files found to compare."); return

            rich_options = []
            for filename in converted_files:
                # The procedure name is the filename without '.sql'
                proc_name = filename[:-4]
                proc_name = re.match(r"^processed_(.*)$", proc_name).group(1) if re.match(r"^processed_(.*)$", proc_name) else None

                status_icon = status_map.get(proc_name, "â”") # Default to '?' if no status found
                
                # # Format the label, e.g., "my_proc.sql  [âœ…]"
                rich_label = f"{filename.ljust(50)} [{status_icon}]"
                rich_label = re.match(r"^processed_(.*)$", rich_label).group(1) if re.match(r"^processed_(.*)$", rich_label) else None
                rich_options.append(rich_label)


            # --- STEP 3: Populate the dropdown with rich labels ---
            options = ["-- Select a procedure to compare --"] + rich_options
            st.selectbox(
                "Choose a procedure (Status: âœ…=Success, âŒ=Failed, â”=Not Tested):", 
                options, 
                key="file_comparator_select",
                on_change=self._load_file_for_editing
            )

            # Display the comparison/editor if a file is selected and loaded
            if st.session_state.editable_file_path:
                # original_file_path = self.extracted_dir / Path(st.session_state.editable_file_path).name
                match = re.match(r"^processed_(.*)$", Path(st.session_state.editable_file_path).name)
                if match:
                    original_filename = match.group(1)
                    original_file_path = self.extracted_dir / original_filename
                else:
                    original_file_path = None
                original_content = self.read_file_content(original_file_path)


                # re.match(r"^processed_(.*)$", st.session_state.editable_file_path).group(1) if re.match(r"^processed_(.*)$", st.session_state.editable_file_path) else None


                col1, col2 = st.columns(2)
                with col1:
                    st.markdown(f"**Original Script** (`{original_file_path}`)")
                    with st.container(height=600):
                        st.code(original_content, language='sql', line_numbers=True)
                
                with col2:
                    st.markdown(f"**Converted Script**")

                                    # --- NEW: Action buttons for the selected file ---
                    btn_col1, btn_col2 = st.columns([1,1])
                    with btn_col1:
                        # The "Edit" button is only shown in view mode
                        if not st.session_state.edit_mode:
                            if st.button("âœï¸ **Edit Script**", use_container_width=True):
                                st.session_state.edit_mode = True
                                st.rerun()
                    
                    with btn_col2:
                        # The "Test" button is always available when a file is selected
                        if st.button("ðŸ§ª **Run Unit Test**", use_container_width=True, help="Run tests for this specific procedure."):
                            st.session_state.test_results = self.run_single_procedure_test()


                                                            # --- NEW: DEDICATED AREA FOR TEST RESULTS ---
                    # This section checks the session state and displays results if they exist.
                    if 'test_results' in st.session_state and st.session_state.test_results is not None:
                        results = st.session_state.test_results
                        
                        # Use a container to group the results visually
                        with st.container(border=True):
                            header_col, btn_hide_col = st.columns([3, 1])
                            with header_col:
                                st.subheader("ðŸ“Š Test Summary")
                            with btn_hide_col:
                                # This button clears the state and triggers a rerun to hide the section
                                if st.button("âŒ Hide", use_container_width=True, type="secondary", help="Clear the test results from view."):
                                    st.session_state.test_results = None
                                    st.rerun()


                            # st.subheader("ðŸ“Š Test Summary")
                            
                            total_tests = len(results)
                            successes = sum(1 for r in results if r[2] == "âœ… Success")
                            failures = total_tests - successes
            
                            # We are in col2, so we can create sub-columns here
                            metric_col1, metric_col2, metric_col3 = st.columns(3)
                            metric_col1.metric("Total Tests", total_tests)
                            metric_col2.metric("Passed âœ…", successes)
                            metric_col3.metric("Failed âŒ", failures, 
                                               delta=f"-{failures}" if failures > 0 else None, 
                                               delta_color="inverse")
                            
                            st.markdown("---")
                            st.subheader("ðŸ“ Detailed Results")
            
                            if not results:
                                st.info("The test run completed but returned no individual test results.")
            
                            for proc_name, test_type, status, reason, output in results:
                                if status == "âœ… Success":
                                    with st.expander(f"âœ… **{test_type}:** Passed", expanded=False):
                                        if output:
                                            st.text("Captured Output:")
                                            st.code(output, language='log')
                                else:
                                    with st.expander(f"âŒ **{test_type}:** Failed", expanded=True):
                                        st.caption("Reason for Failure:")
                                        st.error(reason)
                                        if output:
                                            st.caption("Captured Output / Traceback:")
                                            st.code(output, language='log')




                    # --- CONDITIONAL UI based on edit_mode ---
                    if st.session_state.edit_mode:
                        # --- EDIT MODE ---
                        st.text_area(
                            "Edit the script below:",
                            value=st.session_state.editable_content,
                            height=550,
                            key="editable_sql_content",
                            label_visibility="collapsed"
                        )
                        if st.button("ðŸ’¾ **Save Changes**", use_container_width=True, type="primary"):
                            try:
                                new_content = st.session_state.editable_sql_content
                                file_to_save = Path(st.session_state.editable_file_path)
                                file_to_save.write_text(new_content, encoding='utf-8')
                                st.session_state.editable_content = new_content
                                st.session_state.edit_mode = False # Switch back to view mode
                                st.toast(f"âœ… Saved changes to {file_to_save.name}", icon="ðŸ’¾")
                                st.rerun() # Rerun to show the updated code block
                            except Exception as e:
                                st.error(f"Failed to save file: {e}")
                    else:
                        # --- VIEW MODE ---
                        with st.container(height=550): # Use a container to keep height consistent
                            st.code(st.session_state.editable_content, language='sql', line_numbers=True)
                    

                                      # if st.button("âœï¸ **Edit Script**", use_container_width=True):
                        #     st.session_state.edit_mode = True
                        #     st.rerun() # Rerun to switch to the text_area


                    

        except Exception as e:
            st.error("âŒ An error occurred while setting up the comparison viewer:")
            st.exception(e)






    def run_single_procedure_test(self):
        """
        Finds the corresponding processed file and runs the single-test executor.
        """
        # base_name = Path(st.session_state.editable_file_path).name
        # processed_file_path = self.processed_dir / f"processed_{base_name}"

        processed_file_path= self.processed_dir /Path(st.session_state.editable_file_path).name

        if not processed_file_path.exists():
            st.error(f"âŒ **Test Failed:** Could not find the processed file at `{processed_file_path}`. Please ensure you have run the 'Process All Files' step for this procedure.")
            return None

        importlib.reload(py_test)
        # 1. Call the helper to get data
        with st.spinner("Executing tests..."):
            results = py_test.run_single_test(
                sql_file_path=str(processed_file_path),
                config=self.config
            )
        return results



    def read_file_content(self, file_path: Path) -> str:
        """A helper to safely read file content."""
        if file_path.exists():
            try:
                # Use utf-8-sig to handle potential BOM (Byte Order Mark) from Windows systems
                return file_path.read_text(encoding='utf-8-sig')
            except Exception as e:
                return f"Error reading file: {e}"
        else:
            return f"--- FILE NOT FOUND ---\nPath: {file_path}"